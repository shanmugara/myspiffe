<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/goclient/goclient.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/goclient/goclient.go" />
              <option name="originalContent" value="package goclient&#10;&#10;import (&#10;&#9;&quot;context&quot;&#10;&#9;&quot;fmt&quot;&#10;&#9;&quot;net/http&quot;&#10;&#9;&quot;os&quot;&#10;&#9;&quot;strings&quot;&#10;&#10;&#9;&quot;github.com/spiffe/go-spiffe/v2/spiffetls/tlsconfig&quot;&#10;&#9;&quot;github.com/spiffe/go-spiffe/v2/workloadapi&quot;&#10;)&#10;&#10;func GetTlsClient(ctx context.Context) (*http.Client, error) {&#10;&#9;// Use the caller-provided context directly. Creating a child context and&#10;&#9;// deferring its cancel() here would cancel the context when this function&#10;&#9;// returns, which would make the X509 source unusable by the returned client.&#10;&#10;&#9;addr := os.Getenv(&quot;SPIFFE_ENDPOINT_SOCKET&quot;)&#10;&#9;if addr == &quot;&quot; {&#10;&#9;&#9;addr = &quot;unix:///tmp/agent.sock&quot;&#10;&#9;&#9;Logger.Infof(&quot;Using default socket endpoint: %s&quot;, addr)&#10;&#9;} else {&#10;&#9;&#9;Logger.Infof(&quot;Using socket endpoint from environment: %s&quot;, addr)&#10;&#9;}&#10;&#10;&#9;if !strings.HasPrefix(addr, &quot;unix:&quot;) {&#10;&#9;&#9;addr = &quot;unix://&quot; + addr&#10;&#9;}&#10;&#9;mySvid, err := workloadapi.FetchX509SVID(ctx)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, fmt.Errorf(&quot;unable to fetch X509 SVID: %w&quot;, err)&#10;&#9;}&#10;&#9;myTD := mySvid.ID.TrustDomain()&#10;&#10;&#9;Logger.Infof(&quot;Using trust domain: %s&quot;, myTD)&#10;&#9;Logger.Infof(&quot;Using workload API endpoint: %s&quot;, addr)&#10;&#9;Logger.Infof(&quot;SVID: %s&quot;, mySvid.ID.URL())&#10;&#10;&#9;// Create a `workloadapi.X509Source`, it will connect to Workload API using provided socket path&#10;&#9;// If socket path is not defined using `workloadapi.SourceOption`, value from environment variable `SPIFFE_ENDPOINT_SOCKET` is used.&#10;&#9;source, err := workloadapi.NewX509Source(ctx, workloadapi.WithClientOptions(workloadapi.WithAddr(addr)))&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, fmt.Errorf(&quot;unable to create X509Source: %w&quot;, err)&#10;&#9;}&#10;&#9;// Do NOT close the source here (no defer source.Close()). The returned client's&#10;&#9;// TLS config uses the source for SVIDs and bundle updates; closing it before the&#10;&#9;// client is finished would break mTLS. The caller/process should keep the source&#10;&#9;// alive for the lifetime of the client (or we could change the API to return the&#10;&#9;// source so the caller can close it when appropriate).&#10;&#10;&#9;// Allow connection to my trust domain member servers&#10;&#9;tlsConfig := tlsconfig.MTLSClientConfig(source, source, tlsconfig.AuthorizeMemberOf(myTD))&#10;&#9;client := &amp;http.Client{&#10;&#9;&#9;Transport: &amp;http.Transport{&#10;&#9;&#9;&#9;TLSClientConfig: tlsConfig,&#10;&#9;&#9;},&#10;&#9;}&#10;&#10;&#9;return client, nil&#10;}&#10;" />
              <option name="updatedContent" value="package goclient&#10;&#10;import (&#10;&#9;&quot;context&quot;&#10;&#9;&quot;fmt&quot;&#10;&#9;&quot;net/http&quot;&#10;&#9;&quot;os&quot;&#10;&#9;&quot;strings&quot;&#10;&#10;&#9;&quot;github.com/spiffe/go-spiffe/v2/spiffetls/tlsconfig&quot;&#10;&#9;&quot;github.com/spiffe/go-spiffe/v2/workloadapi&quot;&#10;)&#10;&#10;func GetTlsClient(ctx context.Context) (*http.Client, error) {&#10;&#9;// Use the caller-provided context directly. Creating a child context and&#10;&#9;// deferring its cancel() here would cancel the context when this function&#10;&#9;// returns, which would make the X509 source unusable by the returned client.&#10;&#10;&#9;addr := os.Getenv(&quot;SPIFFE_ENDPOINT_SOCKET&quot;)&#10;&#9;if addr == &quot;&quot; {&#10;&#9;&#9;addr = &quot;unix:///tmp/agent.sock&quot;&#10;&#9;&#9;Logger.Infof(&quot;Using default socket endpoint: %s&quot;, addr)&#10;&#9;} else {&#10;&#9;&#9;Logger.Infof(&quot;Using socket endpoint from environment: %s&quot;, addr)&#10;&#9;}&#10;&#10;&#9;if !strings.HasPrefix(addr, &quot;unix:&quot;) {&#10;&#9;&#9;addr = &quot;unix://&quot; + addr&#10;&#9;}&#10;&#9;mySvid, err := workloadapi.FetchX509SVID(ctx)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, fmt.Errorf(&quot;unable to fetch X509 SVID: %w&quot;, err)&#10;&#9;}&#10;&#9;myTD := mySvid.ID.TrustDomain()&#10;&#10;&#9;Logger.Infof(&quot;Using trust domain: %s&quot;, myTD)&#10;&#9;Logger.Infof(&quot;Using workload API endpoint: %s&quot;, addr)&#10;&#9;Logger.Infof(&quot;SVID: %s&quot;, mySvid.ID.URL())&#10;&#10;&#9;// Create a `workloadapi.X509Source`, it will connect to Workload API using provided socket path&#10;&#9;// If socket path is not defined using `workloadapi.SourceOption`, value from environment variable `SPIFFE_ENDPOINT_SOCKET` is used.&#10;&#9;source, err := workloadapi.NewX509Source(ctx, workloadapi.WithClientOptions(workloadapi.WithAddr(addr)))&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, fmt.Errorf(&quot;unable to create X509Source: %w&quot;, err)&#10;&#9;}&#10;&#9;// Do NOT close the source here (no defer source.Close()). The returned client's&#10;&#9;// TLS config uses the source for SVIDs and bundle updates; closing it before the&#10;&#9;// client is finished would break mTLS. The caller/process should keep the source&#10;&#9;// alive for the lifetime of the client (or we could change the API to return the&#10;&#9;// source so the caller can close it when appropriate).&#10;&#10;&#9;// Allow connection to my trust domain member servers&#10;&#9;tlsConfig := tlsconfig.MTLSClientConfig(source, source, tlsconfig.AuthorizeMemberOf(myTD))&#10;&#9;client := &amp;http.Client{&#10;&#9;&#9;Transport: &amp;http.Transport{&#10;&#9;&#9;&#9;TLSClientConfig: tlsConfig,&#10;&#9;&#9;},&#10;&#9;}&#10;&#10;&#9;return client, nil&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>